var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{};function t(e){return e&&e.__esModule?e.default:e}var n={},r={},o=e.parcelRequireb9f8;null==o&&((o=function(e){if(e in n)return n[e].exports;if(e in r){var t=r[e];delete r[e];var o={id:e,exports:{}};return n[e]=o,t.call(o.exports,o,o.exports),o.exports}var i=Error("Cannot find module '"+e+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(e,t){r[e]=t},e.parcelRequireb9f8=o),o.register("dBs8J",function(e,t){function n(e,t,n,r,o,i){return{tag:e,key:t,attrs:n,children:r,text:o,dom:i,domSize:void 0,state:void 0,events:void 0,instance:void 0}}n.normalize=function(e){return Array.isArray(e)?n("[",void 0,void 0,n.normalizeChildren(e),void 0,void 0):null==e||"boolean"==typeof e?null:"object"==typeof e?e:n("#",void 0,void 0,String(e),void 0,void 0)},n.normalizeChildren=function(e){var t=[];if(e.length){// Note: this is a *very* perf-sensitive check.
// Fun fact: merging the loop like this is somehow faster than splitting
// it, noticeably so.
for(var r=null!=e[0]&&null!=e[0].key,o=1;o<e.length;o++)if((null!=e[o]&&null!=e[o].key)!==r)throw TypeError(r&&(null!=e[o]||"boolean"==typeof e[o])?"In fragments, vnodes must either all have keys or none have keys. You may wish to consider using an explicit keyed empty fragment, m.fragment({key: ...}), instead of a hole.":"In fragments, vnodes must either all have keys or none have keys.");for(var o=0;o<e.length;o++)t[o]=n.normalize(e[o])}return t},e.exports=n}),o.register("e2F9W",function(e,t){var n=o("dBs8J");e.exports=function(e){return null==e&&(e=""),n("<",void 0,void 0,e,void 0,void 0)}}),o.register("7PZrX",function(e,t){var n=o("dBs8J"),r=o("5sRXF");e.exports=function(){var e=r.apply(0,arguments);return e.tag="[",e.children=n.normalizeChildren(e.children),e}}),o.register("5sRXF",function(e,t){var n=o("dBs8J");// Call via `hyperscriptVnode.apply(startOffset, arguments)`
//
// The reason I do it this way, forwarding the arguments and passing the start
// offset in `this`, is so I don't have to create a temporary array in a
// performance-critical path.
//
// In native ES6, I'd instead add a final `...args` parameter to the
// `hyperscript` and `fragment` factories and define this as
// `hyperscriptVnode(...args)`, since modern engines do optimize that away. But
// ES5 (what Mithril.js requires thanks to IE support) doesn't give me that luxury,
// and engines aren't nearly intelligent enough to do either of these:
//
// 1. Elide the allocation for `[].slice.call(arguments, 1)` when it's passed to
//    another function only to be indexed.
// 2. Elide an `arguments` allocation when it's passed to any function other
//    than `Function.prototype.apply` or `Reflect.apply`.
//
// In ES6, it'd probably look closer to this (I'd need to profile it, though):
// module.exports = function(attrs, ...children) {
//     if (attrs == null || typeof attrs === "object" && attrs.tag == null && !Array.isArray(attrs)) {
//         if (children.length === 1 && Array.isArray(children[0])) children = children[0]
//     } else {
//         children = children.length === 0 && Array.isArray(attrs) ? attrs : [attrs, ...children]
//         attrs = undefined
//     }
//
//     if (attrs == null) attrs = {}
//     return Vnode("", attrs.key, attrs, children)
// }
e.exports=function(){var e,t=arguments[this],r=this+1;if(null==t?t={}:("object"!=typeof t||null!=t.tag||Array.isArray(t))&&(t={},r=this),arguments.length===r+1)e=arguments[r],Array.isArray(e)||(e=[e]);else for(e=[];r<arguments.length;)e.push(arguments[r++]);return n("",t.key,t,e)}}),o.register("k7iQv",function(e,t){/** @constructor */var n=function(e){if(!(this instanceof n))throw Error("Promise must be called with 'new'.");if("function"!=typeof e)throw TypeError("executor must be a function.");var t=this,r=[],o=[],i=c(r,!0),a=c(o,!1),l=t._instance={resolvers:r,rejectors:o},s="function"==typeof setImmediate?setImmediate:setTimeout;function c(e,n){return function i(c){var f;try{if(n&&null!=c&&("object"==typeof c||"function"==typeof c)&&"function"==typeof(f=c.then)){if(c===t)throw TypeError("Promise can't be resolved with itself.");u(f.bind(c))}else s(function(){n||0!==e.length||console.error("Possible unhandled promise rejection:",c);for(var t=0;t<e.length;t++)e[t](c);r.length=0,o.length=0,l.state=n,l.retry=function(){i(c)}})}catch(e){a(e)}}}function u(e){var t=0;function n(e){return function(n){t++>0||e(n)}}var r=n(a);try{e(n(i),r)}catch(e){r(e)}}u(e)};n.prototype.then=function(e,t){var r,o,i=this._instance;function a(e,t,n,a){t.push(function(t){if("function"!=typeof e)n(t);else try{r(e(t))}catch(e){o&&o(e)}}),"function"==typeof i.retry&&a===i.state&&i.retry()}var l=new n(function(e,t){r=e,o=t});return a(e,i.resolvers,r,!0),a(t,i.rejectors,o,!1),l},n.prototype.catch=function(e){return this.then(null,e)},n.prototype.finally=function(e){return this.then(function(t){return n.resolve(e()).then(function(){return t})},function(t){return n.resolve(e()).then(function(){return n.reject(t)})})},n.resolve=function(e){return e instanceof n?e:new n(function(t){t(e)})},n.reject=function(e){return new n(function(t,n){n(e)})},n.all=function(e){return new n(function(t,n){var r=e.length,o=0,i=[];if(0===e.length)t([]);else for(var a=0;a<e.length;a++)!function(a){function l(e){o++,i[a]=e,o===r&&t(i)}null!=e[a]&&("object"==typeof e[a]||"function"==typeof e[a])&&"function"==typeof e[a].then?e[a].then(l,n):l(e[a])}(a)})},n.race=function(e){return new n(function(t,n){for(var r=0;r<e.length;r++)e[r].then(t,n)})},e.exports=n}),o.register("j25vk",function(e,t){e.exports=o("6JDlc")("undefined"!=typeof window?window:null)}),o.register("6JDlc",function(e,t){var n=o("dBs8J");e.exports=function(e){var t,r,o=e&&e.document,i={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"};function a(e){return e.attrs&&e.attrs.xmlns||i[e.tag]}//sanity check to discourage people from doing `vnode.state = ...`
function l(e,t){if(e.state!==t)throw Error("'vnode.state' must not be modified.")}//Note: the hook is passed as the `this` argument to allow proxying the
//arguments without requiring a full array allocation to do so. It also
//takes advantage of the fact the current `vnode` is the first argument in
//all lifecycle methods.
function s(e){var t=e.state;try{return this.apply(t,arguments)}finally{l(e,t)}}// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when
// inside an iframe. Catch and swallow this error, and heavy-handidly return null.
function c(){try{return o.activeElement}catch(e){return null}}//create
function u(e,t,n,r,o,i,a){for(var l=n;l<r;l++){var s=t[l];null!=s&&f(e,s,o,a,i)}}function f(e,t,r,i,l){var c=t.tag;if("string"==typeof c)switch(t.state={},null!=t.attrs&&I(t.attrs,t,r),c){case"#":t.dom=o.createTextNode(t.children),w(e,t.dom,l);break;case"<":p(e,t,i,l);break;case"[":(function(e,t,n,r,i){var a=o.createDocumentFragment();if(null!=t.children){var l=t.children;u(a,l,0,l.length,n,null,r)}t.dom=a.firstChild,t.domSize=a.childNodes.length,w(e,a,i)})(e,t,r,i,l);break;default:(function(e,t,n,r,i){var l=t.tag,s=t.attrs,c=s&&s.is,f=(r=a(t)||r)?c?o.createElementNS(r,l,{is:c}):o.createElementNS(r,l):c?o.createElement(l,{is:c}):o.createElement(l);if(t.dom=f,null!=s&&//attrs
function(e,t,n){// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
//
// Also, the DOM does things to inputs based on the value, so it needs set first.
// See: https://github.com/MithrilJS/mithril.js/issues/2622
"input"===e.tag&&null!=t.type&&e.dom.setAttribute("type",t.type);var r=null!=t&&"input"===e.tag&&"file"===t.type;for(var o in t)S(e,o,null,t[o],n,r)}(t,s,r),w(e,f,i),!b(t)&&null!=t.children){var d=t.children;u(f,d,0,d.length,n,null,r),"select"===t.tag&&null!=s&&function(e,t){if("value"in t){if(null===t.value)-1!==e.dom.selectedIndex&&(e.dom.value=null);else{var n=""+t.value// eslint-disable-line no-implicit-coercion
;(e.dom.value!==n||-1===e.dom.selectedIndex)&&(e.dom.value=n)}}"selectedIndex"in t&&S(e,"selectedIndex",null,t.selectedIndex,void 0)}(t,s)}})(e,t,r,i,l)}else(function(e,t){var r;if("function"==typeof e.tag.view){if(e.state=Object.create(e.tag),null!=(r=e.state.view).$$reentrantLock$$)return;r.$$reentrantLock$$=!0}else{if(e.state=void 0,null!=(r=e.tag).$$reentrantLock$$)return;r.$$reentrantLock$$=!0,e.state=null!=e.tag.prototype&&"function"==typeof e.tag.prototype.view?new e.tag(e):e.tag(e)}if(I(e.state,e,t),null!=e.attrs&&I(e.attrs,e,t),e.instance=n.normalize(s.call(e.state.view,e)),e.instance===e)throw Error("A view cannot return the vnode it received as argument");r.$$reentrantLock$$=null})(t,r),null!=t.instance?(f(e,t.instance,r,i,l),t.dom=t.instance.dom,t.domSize=null!=t.dom?t.instance.domSize:0):t.domSize=0}var d={caption:"table",thead:"table",tbody:"table",tfoot:"table",tr:"tbody",th:"tr",td:"tr",colgroup:"table",col:"colgroup"};function p(e,t,n,r){var i,a=t.children.match(/^\s*?<(\w+)/im)||[],l=o.createElement(d[a[1]]||"div");"http://www.w3.org/2000/svg"===n?(l.innerHTML='<svg xmlns="http://www.w3.org/2000/svg">'+t.children+"</svg>",l=l.firstChild):l.innerHTML=t.children,t.dom=l.firstChild,t.domSize=l.childNodes.length,// Capture nodes to remove, so we don't confuse them.
t.instance=[];for(var s=o.createDocumentFragment();i=l.firstChild;)t.instance.push(i),s.appendChild(i);w(e,s,r)}//update
/**
	 * @param {Element|Fragment} parent - the parent element
	 * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for
	 *                               this part of the tree
	 * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.
	 * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)
	 * @param {Element | null} nextSibling - the next DOM node if we're dealing with a
	 *                                       fragment that is not the last item in its
	 *                                       parent
	 * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any
	 * @returns void
	 */// This function diffs and patches lists of vnodes, both keyed and unkeyed.
//
// We will:
//
// 1. describe its general structure
// 2. focus on the diff algorithm optimizations
// 3. discuss DOM node operations.
// ## Overview:
//
// The updateNodes() function:
// - deals with trivial cases
// - determines whether the lists are keyed or unkeyed based on the first non-null node
//   of each list.
// - diffs them and patches the DOM if needed (that's the brunt of the code)
// - manages the leftovers: after diffing, are there:
//   - old nodes left to remove?
// 	 - new nodes to insert?
// 	 deal with them!
//
// The lists are only iterated over once, with an exception for the nodes in `old` that
// are visited in the fourth part of the diff and in the `removeNodes` loop.
// ## Diffing
//
// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837
// may be good for context on longest increasing subsequence-based logic for moving nodes.
//
// In order to diff keyed lists, one has to
//
// 1) match nodes in both lists, per key, and update them accordingly
// 2) create the nodes present in the new list, but absent in the old one
// 3) remove the nodes present in the old list, but absent in the new one
// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.
//
// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate
// over the new list and for each new vnode, find the corresponding vnode in the old list using
// the map.
// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new
// and must be created.
// For the removals, we actually remove the nodes that have been updated from the old list.
// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.
// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)
// algorithm.
//
// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going
// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices
// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would
//  match the above lists, for example).
//
// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We
// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.
//
// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually
// the longest increasing subsequence *of old nodes still present in the new list*).
//
// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation
// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,
// the `LIS` and a temporary one to create the LIS).
//
// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of
// the LIS and can be updated without moving them.
//
// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with
// the exception of the last node if the list is fully reversed).
//
// ## Finding the next sibling.
//
// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.
// When the list is being traversed top-down, at any index, the DOM nodes up to the previous
// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old
// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.
//
// In the other scenarios (swaps, upwards traversal, map-based diff),
// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the
// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node
// as the next sibling (cached in the `nextSibling` variable).
// ## DOM node moves
//
// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,
// this is not the case if the node moved (second and fourth part of the diff algo). We move
// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`
// variable rather than fetching it using `getNextSibling()`.
//
// The fourth part of the diff currently inserts nodes unconditionally, leading to issues
// like #1791 and #1999. We need to be smarter about those situations where adjascent old
// nodes remain together in the new list in a way that isn't covered by parts one and
// three of the diff algo.
function m(e,t,n,r,o,i){if(t!==n&&(null!=t||null!=n)){if(null==t||0===t.length)u(e,n,0,n.length,r,o,i);else if(null==n||0===n.length)x(e,t,0,t.length);else{var a=null!=t[0]&&null!=t[0].key,l=null!=n[0]&&null!=n[0].key,s=0,c=0;if(!a)for(;c<t.length&&null==t[c];)c++;if(!l)for(;s<n.length&&null==n[s];)s++;if(a!==l)x(e,t,c,t.length),u(e,n,s,n.length,r,o,i);else if(l){// bottom-up
for(// keyed diff
var d,p,m,w,b,E,O=t.length-1,j=n.length-1;O>=c&&j>=s&&(w=t[O],b=n[j],w.key===b.key);)w!==b&&h(e,w,b,r,o,i),null!=b.dom&&(o=b.dom),O--,j--;// top-down
for(;O>=c&&j>=s&&(p=t[c],m=n[s],p.key===m.key);)c++,s++,p!==m&&h(e,p,m,r,g(t,c,o),i);// swaps and list reversals
for(;O>=c&&j>=s&&s!==j&&p.key===b.key&&w.key===m.key;)y(e,w,E=g(t,c,o)),w!==m&&h(e,w,m,r,E,i),++s<=--j&&y(e,p,o),p!==b&&h(e,p,b,r,o,i),null!=b.dom&&(o=b.dom),c++,w=t[--O],b=n[j],p=t[c],m=n[s];// bottom up once again
for(;O>=c&&j>=s&&w.key===b.key;)w!==b&&h(e,w,b,r,o,i),null!=b.dom&&(o=b.dom),O--,j--,w=t[O],b=n[j];if(s>j)x(e,t,c,O+1);else if(c>O)u(e,n,s,j+1,r,o,i);else{// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul
var d,S,L=o,N=j-s+1,P=Array(N),A=0,T=0,C=2147483647,R=0;for(T=0;T<N;T++)P[T]=-1;for(T=j;T>=s;T--){null==d&&(d=function(e,t,n){for(var r=Object.create(null);t<n;t++){var o=e[t];if(null!=o){var i=o.key;null!=i&&(r[i]=t)}}return r}(t,c,O+1));var z=d[(b=n[T]).key];null!=z&&(C=z<C?z:-1// becomes -1 if nodes were re-ordered
,P[T-s]=z,w=t[z],t[z]=null,w!==b&&h(e,w,b,r,o,i),null!=b.dom&&(o=b.dom),R++)}if(o=L,R!==O-c+1&&x(e,t,c,O+1),0===R)u(e,n,s,j+1,r,o,i);else if(-1===C)for(A=// the indices of the indices of the items that are part of the
// longest increasing subsequence in the oldIndices list
(S=function(e){for(var t=[0],n=0,r=0,o=0,i=v.length=e.length,o=0;o<i;o++)v[o]=e[o];for(var o=0;o<i;++o)if(-1!==e[o]){var a=t[t.length-1];if(e[a]<e[o]){v[o]=a,t.push(o);continue}for(n=0,r=t.length-1;n<r;){// Fast integer average without overflow.
// eslint-disable-next-line no-bitwise
var l=(n>>>1)+(r>>>1)+(n&r&1);e[t[l]]<e[o]?n=l+1:r=l}e[o]<e[t[n]]&&(n>0&&(v[o]=t[n-1]),t[n]=o)}for(n=t.length,r=t[n-1];n-- >0;)t[n]=r,r=v[r];return v.length=0,t}(P)).length-1,T=j;T>=s;T--)m=n[T],-1===P[T-s]?f(e,m,r,i,o):S[A]===T-s?A--:y(e,m,o),null!=m.dom&&(o=n[T].dom);else for(T=j;T>=s;T--)m=n[T],-1===P[T-s]&&f(e,m,r,i,o),null!=m.dom&&(o=n[T].dom)}}else{// Don't index past the end of either list (causes deopts).
var I=t.length<n.length?t.length:n.length;for(// Rewind if necessary to the first non-null index on either side.
// We could alternatively either explicitly create or remove nodes when `start !== oldStart`
// but that would be optimizing for sparse lists which are more rare than dense ones.
s=s<c?s:c;s<I;s++)(p=t[s])!==(m=n[s])&&(null!=p||null!=m)&&(null==p?f(e,m,r,i,g(t,s+1,o)):null==m?k(e,p):h(e,p,m,r,g(t,s+1,o),i));t.length>I&&x(e,t,s,t.length),n.length>I&&u(e,n,s,n.length,r,o,i)}}}}function h(e,t,r,o,i,l){var u,d,v=t.tag;if(v===r.tag){if(r.state=t.state,r.events=t.events,function(e,t){do{if(null!=e.attrs&&"function"==typeof e.attrs.onbeforeupdate){var n=s.call(e.attrs.onbeforeupdate,e,t);if(void 0!==n&&!n)break}if("string"!=typeof e.tag&&"function"==typeof e.state.onbeforeupdate){var n=s.call(e.state.onbeforeupdate,e,t);if(void 0!==n&&!n)break}return!1}while(!1)// eslint-disable-line no-constant-condition
return e.dom=t.dom,e.domSize=t.domSize,e.instance=t.instance,// One would think having the actual latest attributes would be ideal,
// but it doesn't let us properly diff based on our current internal
// representation. We have to save not only the old DOM info, but also
// the attributes used to create it, as we diff *that*, not against the
// DOM directly (with a few exceptions in `setAttr`). And, of course, we
// need to save the children and text as they are conceptually not
// unlike special "attributes" internally.
e.attrs=t.attrs,e.children=t.children,e.text=t.text,!0}(r,t))return;if("string"==typeof v)switch(null!=r.attrs&&_(r.attrs,r,o),v){case"#":t.children.toString()!==r.children.toString()&&(t.dom.nodeValue=r.children),r.dom=t.dom;break;case"<":t.children!==r.children?(E(e,t),p(e,r,l,i)):(r.dom=t.dom,r.domSize=t.domSize,r.instance=t.instance);break;case"[":(function(e,t,n,r,o,i){m(e,t.children,n.children,r,o,i);var a=0,l=n.children;if(n.dom=null,null!=l){for(var s=0;s<l.length;s++){var c=l[s];null!=c&&null!=c.dom&&(null==n.dom&&(n.dom=c.dom),a+=c.domSize||1)}1!==a&&(n.domSize=a)}})(e,t,r,o,i,l);break;default:u=l,d=r.dom=t.dom,u=a(r)||u,"textarea"===r.tag&&null==r.attrs&&(r.attrs={}),function(e,t,n,r){if(t&&t===n&&console.warn("Don't reuse attrs object, use new object for every redraw, this will throw in next major"),null!=n){// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
//
// Also, the DOM does things to inputs based on the value, so it needs set first.
// See: https://github.com/MithrilJS/mithril.js/issues/2622
"input"===e.tag&&null!=n.type&&e.dom.setAttribute("type",n.type);var o,i="input"===e.tag&&"file"===n.type;for(var a in n)S(e,a,t&&t[a],n[a],r,i)}if(null!=t)for(var a in t)null!=(o=t[a])&&(null==n||null==n[a])&&function(e,t,n,r){if(!("key"===t||"is"===t||null==n||L(t))){if("o"===t[0]&&"n"===t[1])z(e,t,void 0);else if("style"===t)C(e.dom,n,null);else if(N(e,t,r)&&"className"!==t&&"title"// creates "null" as title
!==t&&("value"!==t||"option"!==e.tag&&("select"!==e.tag||-1!==e.dom.selectedIndex||e.dom!==c()))&&("input"!==e.tag||"type"!==t))e.dom[t]=null;else{var o=t.indexOf(":");-1!==o&&(t=t.slice(o+1)),!1!==n&&e.dom.removeAttribute("className"===t?"class":t)}}}(e,a,o,r)}(r,t.attrs,r.attrs,u),b(r)||m(d,t.children,r.children,o,null,u)}else(function(e,t,r,o,i,a){if(r.instance=n.normalize(s.call(r.state.view,r)),r.instance===r)throw Error("A view cannot return the vnode it received as argument");_(r.state,r,o),null!=r.attrs&&_(r.attrs,r,o),null!=r.instance?(null==t.instance?f(e,r.instance,o,a,i):h(e,t.instance,r.instance,o,i,a),r.dom=r.instance.dom,r.domSize=r.instance.domSize):null!=t.instance?(k(e,t.instance),r.dom=void 0,r.domSize=0):(r.dom=t.dom,r.domSize=t.domSize)})(e,t,r,o,i,l)}else k(e,t),f(e,r,o,l,i)}// Lifted from ivi https://github.com/ivijs/ivi/
// takes a list of unique numbers (-1 is special and can
// occur multiple times) and returns an array with the indices
// of the items that are part of the longest increasing
// subsequence
var v=[];function g(e,t,n){for(;t<e.length;t++)if(null!=e[t]&&null!=e[t].dom)return e[t].dom;return n}// This covers a really specific edge case:
// - Parent node is keyed and contains child
// - Child is removed, returns unresolved promise in `onbeforeremove`
// - Parent node is moved in keyed diff
// - Remaining children still need moved appropriately
//
// Ideally, I'd track removed nodes as well, but that introduces a lot more
// complexity and I'm not exactly interested in doing that.
function y(e,t,n){var r=o.createDocumentFragment();(function e(t,n,r){// Dodge the recursion overhead in a few of the most common cases.
for(;null!=r.dom&&r.dom.parentNode===t;){if("string"!=typeof r.tag){if(null!=(r=r.instance))continue}else if("<"===r.tag)for(var o=0;o<r.instance.length;o++)n.appendChild(r.instance[o]);else if("["!==r.tag)n.appendChild(r.dom);else if(1===r.children.length){if(null!=(r=r.children[0]))continue}else for(var o=0;o<r.children.length;o++){var i=r.children[o];null!=i&&e(t,n,i)}break}})(e,r,t),w(e,r,n)}function w(e,t,n){null!=n?e.insertBefore(t,n):e.appendChild(t)}function b(e){if(null==e.attrs||null==e.attrs.contenteditable&&// attribute
null// property
==e.attrs.contentEditable)return!1;var t=e.children;if(null!=t&&1===t.length&&"<"===t[0].tag){var n=t[0].children;e.dom.innerHTML!==n&&(e.dom.innerHTML=n)}else if(null!=t&&0!==t.length)throw Error("Child node of a contenteditable must be trusted.");return!0}//remove
function x(e,t,n,r){for(var o=n;o<r;o++){var i=t[o];null!=i&&k(e,i)}}function k(e,t){var n,r,o=0,i=t.state;if("string"!=typeof t.tag&&"function"==typeof t.state.onbeforeremove){var a=s.call(t.state.onbeforeremove,t);null!=a&&"function"==typeof a.then&&(o=1,n=a)}if(t.attrs&&"function"==typeof t.attrs.onbeforeremove){var a=s.call(t.attrs.onbeforeremove,t);null!=a&&"function"==typeof a.then&&(// eslint-disable-next-line no-bitwise
o|=2,r=a)}// If we can, try to fast-path it and avoid all the overhead of awaiting
if(l(t,i),o){if(null!=n){var c=function(){// eslint-disable-next-line no-bitwise
!(1&o)||(o&=2)||u()};n.then(c,c)}if(null!=r){var c=function(){// eslint-disable-next-line no-bitwise
!(2&o)||(o&=1)||u()};r.then(c,c)}}else j(t),O(e,t);function u(){l(t,i),j(t),O(e,t)}}function E(e,t){for(var n=0;n<t.instance.length;n++)e.removeChild(t.instance[n])}function O(e,t){// Dodge the recursion overhead in a few of the most common cases.
for(;null!=t.dom&&t.dom.parentNode===e;){if("string"!=typeof t.tag){if(null!=(t=t.instance))continue}else if("<"===t.tag)E(e,t);else{if("["!==t.tag&&(e.removeChild(t.dom),!Array.isArray(t.children)))break;if(1===t.children.length){if(null!=(t=t.children[0]))continue}else for(var n=0;n<t.children.length;n++){var r=t.children[n];null!=r&&O(e,r)}}break}}function j(e){if("string"!=typeof e.tag&&"function"==typeof e.state.onremove&&s.call(e.state.onremove,e),e.attrs&&"function"==typeof e.attrs.onremove&&s.call(e.attrs.onremove,e),"string"!=typeof e.tag)null!=e.instance&&j(e.instance);else{var t=e.children;if(Array.isArray(t))for(var n=0;n<t.length;n++){var r=t[n];null!=r&&j(r)}}}function S(e,t,n,r,i,a){if(!("key"===t||"is"===t||null==r||L(t))&&(n!==r||"value"===t||"checked"===t||"selectedIndex"===t||"selected"===t&&e.dom===c()||"option"===e.tag&&e.dom.parentNode===o.activeElement||"object"==typeof r)&&("type"!==t||"input"!==e.tag)){if("o"===t[0]&&"n"===t[1])return z(e,t,r);if("xlink:"===t.slice(0,6))e.dom.setAttributeNS("http://www.w3.org/1999/xlink",t.slice(6),r);else if("style"===t)C(e.dom,n,r);else if(N(e,t,i)){if("value"===t){// Only do the coercion if we're actually going to check the value.
/* eslint-disable no-implicit-coercion *///setting input[value] to same value by typing on focused element moves cursor to end in Chrome
//setting input[type=file][value] to same value causes an error to be generated if it's non-empty
if(("input"===e.tag||"textarea"===e.tag)&&e.dom.value===""+r&&(a||e.dom===c())||"select"===e.tag&&null!==n&&e.dom.value===""+r||"option"===e.tag&&null!==n&&e.dom.value===""+r)return;//setting input[type=file][value] to different value is an error if it's non-empty
// Not ideal, but it at least works around the most common source of uncaught exceptions for now.
if(a&&""+r!=""){console.error("`value` is read-only on file inputs!");return}/* eslint-enable no-implicit-coercion */}e.dom[t]=r}else"boolean"==typeof r?r?e.dom.setAttribute(t,""):e.dom.removeAttribute(t):e.dom.setAttribute("className"===t?"class":t,r)}}function L(e){return"oninit"===e||"oncreate"===e||"onupdate"===e||"onremove"===e||"onbeforeremove"===e||"onbeforeupdate"===e}function N(e,t,n){// Filter out namespaced keys
return void 0===n&&// If it's a custom element, just keep it.
(e.tag.indexOf("-")>-1||null!=e.attrs&&e.attrs.is||// If it's a normal element, let's try to avoid a few browser bugs.
"href"!==t&&"list"!==t&&"form"!==t&&"width"!==t&&"height"// && key !== "type"
!==t)&&t in e.dom}//style
var P=/[A-Z]/g;function A(e){return"-"+e.toLowerCase()}function T(e){return"-"===e[0]&&"-"===e[1]?e:"cssFloat"===e?"float":e.replace(P,A)}function C(e,t,n){if(t===n);else if(null==n)e.style.cssText="";else if("object"!=typeof n)e.style.cssText=n;else if(null==t||"object"!=typeof t)// Add new style properties
for(var r in // `old` is missing or a string, `style` is an object.
e.style.cssText="",n){var o=n[r];null!=o&&e.style.setProperty(T(r),String(o))}else{// Both old & new are (different) objects.
// Update style properties that have changed
for(var r in n){var o=n[r];null!=o&&(o=String(o))!==String(t[r])&&e.style.setProperty(T(r),o)}// Remove style properties that no longer exist
for(var r in t)null!=t[r]&&null==n[r]&&e.style.removeProperty(T(r))}}// Here's an explanation of how this works:
// 1. The event names are always (by design) prefixed by `on`.
// 2. The EventListener interface accepts either a function or an object
//    with a `handleEvent` method.
// 3. The object does not inherit from `Object.prototype`, to avoid
//    any potential interference with that (e.g. setters).
// 4. The event name is remapped to the handler before calling it.
// 5. In function-based event handlers, `ev.target === this`. We replicate
//    that below.
// 6. In function-based event handlers, `return false` prevents the default
//    action and stops event propagation. We replicate that below.
function R(){// Save this, so the current redraw is correctly tracked.
this._=t}//event
function z(e,n,r){null!=e.events?(e.events._=t,e.events[n]!==r&&(null!=r&&("function"==typeof r||"object"==typeof r)?(null==e.events[n]&&e.dom.addEventListener(n.slice(2),e.events,!1),e.events[n]=r):(null!=e.events[n]&&e.dom.removeEventListener(n.slice(2),e.events,!1),e.events[n]=void 0))):null!=r&&("function"==typeof r||"object"==typeof r)&&(e.events=new R,e.dom.addEventListener(n.slice(2),e.events,!1),e.events[n]=r)}//lifecycle
function I(e,t,n){"function"==typeof e.oninit&&s.call(e.oninit,t),"function"==typeof e.oncreate&&n.push(s.bind(e.oncreate,t))}function _(e,t,n){"function"==typeof e.onupdate&&n.push(s.bind(e.onupdate,t))}return R.prototype=Object.create(null),R.prototype.handleEvent=function(e){var t,n=this["on"+e.type];"function"==typeof n?t=n.call(e.currentTarget,e):"function"==typeof n.handleEvent&&n.handleEvent(e),this._&&!1!==e.redraw&&(0,this._)(),!1===t&&(e.preventDefault(),e.stopPropagation())},function(e,o,i){if(!e)throw TypeError("DOM element being rendered to does not exist.");if(null!=r&&e.contains(r))throw TypeError("Node is currently being rendered to and thus is locked.");var a=t,l=r,s=[],u=c(),f=e.namespaceURI;r=e,t="function"==typeof i?i:void 0;try{null==e.vnodes&&(e.textContent=""),o=n.normalizeChildren(Array.isArray(o)?o:[o]),m(e,e.vnodes,o,s,null,"http://www.w3.org/1999/xhtml"===f?void 0:f),e.vnodes=o,null!=u&&c()!==u&&"function"==typeof u.focus&&u.focus();for(var d=0;d<s.length;d++)s[d]()}finally{t=a,r=l}}}}),o.register("iZais",function(e,t){var n=o("dBs8J");e.exports=function(e,t,r){var o=[],i=!1,a=-1;function l(){for(a=0;a<o.length;a+=2)try{e(o[a],n(o[a+1]),s)}catch(e){r.error(e)}a=-1}function s(){i||(i=!0,t(function(){i=!1,l()}))}return s.sync=l,{mount:function(t,r){if(null!=r&&null==r.view&&"function"!=typeof r)throw TypeError("m.mount expects a component, not a vnode.");var i=o.indexOf(t);i>=0&&(o.splice(i,2),i<=a&&(a-=2),e(t,[])),null!=r&&(o.push(t,r),e(t,n(r),s))},redraw:s}}}),o.register("5y2KI",function(e,t){var n=o("cITMw"),r=o("9eOch");e.exports=function(e,t,o){var i=0;function a(e){return new t(e)}function l(e){return function(r,i){"string"!=typeof r?(i=r,r=r.url):null==i&&(i={});var l=new t(function(t,o){e(n(r,i.params),i,function(e){if("function"==typeof i.type){if(Array.isArray(e))for(var n=0;n<e.length;n++)e[n]=new i.type(e[n]);else e=new i.type(e)}t(e)},o)});if(!0===i.background)return l;var s=0;function c(){0==--s&&"function"==typeof o&&o()}return function e(t){var n=t.then;return(// Set the constructor, so engines know to not await or resolve
// this as a native promise. At the time of writing, this is
// only necessary for V8, but their behavior is the correct
// behavior per spec. See this spec issue for more details:
// https://github.com/tc39/ecma262/issues/1577. Also, see the
// corresponding comment in `request/tests/test-request.js` for
// a bit more background on the issue at hand.
t.constructor=a,t.then=function(){s++;var r=n.apply(t,arguments);return r.then(c,function(e){if(c(),0===s)throw e}),e(r)},t)}(l)}}function s(e,t){for(var n in e.headers)if(r.call(e.headers,n)&&n.toLowerCase()===t)return!0;return!1}return(// In case the global Promise is some userland library's where they rely on
// `foo instanceof this.constructor`, `this.constructor.resolve(value)`, or
// similar. Let's *not* break them.
a.prototype=t.prototype,a.__proto__=t// eslint-disable-line no-proto
,{request:l(function(t,n,o,i){var a,l=null!=n.method?n.method.toUpperCase():"GET",c=n.body,u=(null==n.serialize||n.serialize===JSON.serialize)&&!(c instanceof e.FormData||c instanceof e.URLSearchParams),f=n.responseType||("function"==typeof n.extract?"":"json"),d=new e.XMLHttpRequest,p=!1,m=!1,h=d,v=d.abort;for(var g in d.abort=function(){p=!0,v.call(this)},d.open(l,t,!1!==n.async,"string"==typeof n.user?n.user:void 0,"string"==typeof n.password?n.password:void 0),u&&null!=c&&!s(n,"content-type")&&d.setRequestHeader("Content-Type","application/json; charset=utf-8"),"function"==typeof n.deserialize||s(n,"accept")||d.setRequestHeader("Accept","application/json, text/*"),n.withCredentials&&(d.withCredentials=n.withCredentials),n.timeout&&(d.timeout=n.timeout),d.responseType=f,n.headers)r.call(n.headers,g)&&d.setRequestHeader(g,n.headers[g]);d.onreadystatechange=function(e){// Don't throw errors on xhr.abort().
if(!p&&4===e.target.readyState)try{var r,a=e.target.status>=200&&e.target.status<300||304===e.target.status||/^file:\/\//i.test(t),l=e.target.response;if("json"===f)// For IE and Edge, which don't implement
// `responseType: "json"`.
{if(!e.target.responseType&&"function"!=typeof n.extract)try{l=JSON.parse(e.target.responseText)}catch(e){l=null}}else f&&"text"!==f||null!=l||(l=e.target.responseText);if("function"==typeof n.extract?(l=n.extract(e.target,n),a=!0):"function"==typeof n.deserialize&&(l=n.deserialize(l)),a)o(l);else{var s=function(){try{r=e.target.responseText}catch(e){r=l}var t=Error(r);t.code=e.target.status,t.response=l,i(t)};0===d.status?// This allows `xhr.ontimeout` to run in the case that there is a timeout
// Without this setTimeout, `xhr.ontimeout` doesn't have a chance to reject
// as `xhr.onreadystatechange` will run before it
setTimeout(function(){m||s()}):s()}}catch(e){i(e)}},d.ontimeout=function(e){m=!0;var t=Error("Request timed out");t.code=e.target.status,i(t)},"function"==typeof n.config&&(d=n.config(d,n,t)||d)!==h&&(a=d.abort,d.abort=function(){p=!0,a.call(this)}),null==c?d.send():"function"==typeof n.serialize?d.send(n.serialize(c)):c instanceof e.FormData||c instanceof e.URLSearchParams?d.send(c):d.send(JSON.stringify(c))}),jsonp:l(function(t,n,r,o){var a=n.callbackName||"_mithril_"+Math.round(1e16*Math.random())+"_"+i++,l=e.document.createElement("script");e[a]=function(t){delete e[a],l.parentNode.removeChild(l),r(t)},l.onerror=function(){delete e[a],l.parentNode.removeChild(l),o(Error("JSONP request failed"))},l.src=t+(0>t.indexOf("?")?"?":"&")+encodeURIComponent(n.callbackKey||"callback")+"="+encodeURIComponent(a),e.document.documentElement.appendChild(l)})})}}),o.register("cITMw",function(e,t){var n=o("iRA82"),r=o("enXzN");// Returns `path` from `template` + `params`
e.exports=function(e,t){if(/:([^\/\.-]+)(\.{3})?:/.test(e))throw SyntaxError("Template parameter names must be separated by either a '/', '-', or '.'.");if(null==t)return e;var o=e.indexOf("?"),i=e.indexOf("#"),a=i<0?e.length:i,l=o<0?a:o,s=e.slice(0,l),c={};r(c,t);var u=s.replace(/:([^\/\.-]+)(\.{3})?/g,function(e,n,r){return(// If no such parameter exists, don't interpolate it.
(delete c[n],null==t[n])?e:r?t[n]:encodeURIComponent(String(t[n])))}),f=u.indexOf("?"),d=u.indexOf("#"),p=d<0?u.length:d,m=f<0?p:f,h=u.slice(0,m);o>=0&&(h+=e.slice(o,a)),f>=0&&(h+=(o<0?"?":"&")+u.slice(f,p));var v=n(c);return v&&(h+=(o<0&&f<0?"?":"&")+v),i>=0&&(h+=e.slice(i)),d>=0&&(h+=(i<0?"":"&")+u.slice(d)),h}}),o.register("iRA82",function(e,t){e.exports=function(e){if("[object Object]"!==Object.prototype.toString.call(e))return"";var t=[];for(var n in e)(function e(n,r){if(Array.isArray(r))for(var o=0;o<r.length;o++)e(n+"["+o+"]",r[o]);else if("[object Object]"===Object.prototype.toString.call(r))for(var o in r)e(n+"["+o+"]",r[o]);else t.push(encodeURIComponent(n)+(null!=r&&""!==r?"="+encodeURIComponent(r):""))})(n,e[n]);return t.join("&")}}),o.register("enXzN",function(e,t){var n=o("9eOch");e.exports=Object.assign||function(e,t){for(var r in t)n.call(t,r)&&(e[r]=t[r])}}),o.register("9eOch",function(e,t){e.exports=({}).hasOwnProperty}),o.register("4Ppi2",function(e,t){var n=o("7EF0O");e.exports=o("eFHZ8")("undefined"!=typeof window?window:null,n)}),o.register("7EF0O",function(e,t){var n=o("j25vk");e.exports=o("iZais")(n,"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:null,"undefined"!=typeof console?console:null)}),o.register("eFHZ8",function(e,t){var n=o("dBs8J"),r=o("iVcuU"),i=o("2uPnQ"),a=o("cITMw"),l=o("7lWrV"),s=o("8KlxE"),c=o("enXzN"),u=o("e9o88"),f={};function d(e){try{return decodeURIComponent(e)}catch(t){return e}}e.exports=function(e,t){var o,p,m,h,v,g,y=null==e?null:"function"==typeof e.setImmediate?e.setImmediate:e.setTimeout,w=i.resolve(),b=!1,x=!1,k=0,E=f,O={onbeforeupdate:function(){return!(!(k=k?2:1)||f===E)},onremove:function(){e.removeEventListener("popstate",L,!1),e.removeEventListener("hashchange",S,!1)},view:function(){if(k&&f!==E){// Wrap in a fragment to preserve existing key semantics
var e=[n(m,h.key,h)];return E&&(e=E.render(e[0])),e}}},j=P.SKIP={};function S(){b=!1;// Consider the pathname holistically. The prefix might even be invalid,
// but that's not our problem.
var n=e.location.hash;"#"!==P.prefix[0]&&(n=e.location.search+n,"?"!==P.prefix[0]&&"/"!==(n=e.location.pathname+n)[0]&&(n="/"+n));// This seemingly useless `.concat()` speeds up the tests quite a bit,
// since the representation is consistently a relatively poorly
// optimized cons string.
var r=n.concat().replace(/(?:%[a-f89][a-f0-9])+/gim,d).slice(P.prefix.length),i=l(r);function a(e){console.error(e),N(p,null,{replace:!0})}c(i.params,e.history.state),function e(n){// state === 0: init
// state === 1: scheduled
// state === 2: done
for(;n<o.length;n++)if(o[n].check(i)){var l=o[n].component,s=o[n].route,c=l,u=g=function(o){if(u===g){if(o===j)return e(n+1);m=null!=o&&("function"==typeof o.view||"function"==typeof o)?o:"div",h=i.params,v=r,g=null,E=l.render?l:null,2===k?t.redraw():(k=2,t.redraw.sync())}};// There's no understating how much I *wish* I could
// use `async`/`await` here...
l.view||"function"==typeof l?(l={},u(c)):l.onmatch?w.then(function(){return l.onmatch(i.params,r,s)}).then(u,r===p?null:a):u("div");return}if(r===p)throw Error("Could not resolve default route "+p+".");N(p,null,{replace:!0})}(0)}// Set it unconditionally so `m.route.set` and `m.route.Link` both work,
// even if neither `pushState` nor `hashchange` are supported. It's
// cleared if `hashchange` is used, since that makes it automatically
// async.
function L(){b||(b=!0,// TODO: just do `mountRedraw.redraw()` here and elide the timer
// dependency. Note that this will muck with tests a *lot*, so it's
// not as easy of a change as it sounds.
y(S))}function N(t,n,r){if(t=a(t,n),x){L();var o=r?r.state:null,i=r?r.title:null;r&&r.replace?e.history.replaceState(o,i,P.prefix+t):e.history.pushState(o,i,P.prefix+t)}else e.location.href=P.prefix+t}function P(n,r,i){if(!n)throw TypeError("DOM element being rendered to does not exist.");if(o=Object.keys(i).map(function(e){if("/"!==e[0])throw SyntaxError("Routes must start with a '/'.");if(/:([^\/\.-]+)(\.{3})?:/.test(e))throw SyntaxError("Route parameter names must be separated with either '/', '.', or '-'.");return{route:e,component:i[e],check:s(e)}}),p=r,null!=r){var a=l(r);if(!o.some(function(e){return e.check(a)}))throw ReferenceError("Default route doesn't match any known routes.")}"function"==typeof e.history.pushState?e.addEventListener("popstate",L,!1):"#"===P.prefix[0]&&e.addEventListener("hashchange",S,!1),x=!0,t.mount(n,O),S()}return P.set=function(e,t,n){null!=g&&((n=n||{}).replace=!0),g=null,N(e,t,n)},P.get=function(){return v},P.prefix="#!",P.Link={view:function(e){// Omit the used parameters from the rendered element - they are
// internal. Also, censor the various lifecycle methods.
//
// We don't strip the other parameters because for convenience we
// let them be specified in the selector as well.
var t,n,o,i=r(e.attrs.selector||"a",u(e.attrs,["options","params","selector","onclick"]),e.children);return(i.attrs.disabled=!!i.attrs.disabled)?(i.attrs.href=null,i.attrs["aria-disabled"]="true"):(t=e.attrs.options,n=e.attrs.onclick,// Easier to build it now to keep it isomorphic.
o=a(i.attrs.href,e.attrs.params),i.attrs.href=P.prefix+o,i.attrs.onclick=function(e){var r;"function"==typeof n?r=n.call(e.currentTarget,e):null==n||"object"!=typeof n||"function"==typeof n.handleEvent&&n.handleEvent(e),!1===r||e.defaultPrevented||// Ignore everything but left clicks
0!==e.button&&0!==e.which&&1!==e.which||// Let the browser handle `target=_blank`, etc.
e.currentTarget.target&&"_self"!==e.currentTarget.target||e.ctrlKey||e.metaKey||e.shiftKey||e.altKey||(e.preventDefault(),e.redraw=!1,P.set(o,null,t))}),i}},P.param=function(e){return h&&null!=e?h[e]:h},P}}),o.register("iVcuU",function(e,t){var n=o("dBs8J"),r=o("5sRXF"),i=o("9eOch"),a=/(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g,l={};function s(e){for(var t in e)if(i.call(e,t))return!1;return!0}e.exports=function(e){if(null==e||"string"!=typeof e&&"function"!=typeof e&&"function"!=typeof e.view)throw Error("The selector must be either a string or a component.");var t=r.apply(1,arguments);return"string"==typeof e&&(t.children=n.normalizeChildren(t.children),"["!==e)?function(e,t){var n=t.attrs,r=i.call(n,"class"),o=r?n.class:n.className;if(t.tag=e.tag,t.attrs={},!s(e.attrs)&&!s(n)){var a={};for(var l in n)i.call(n,l)&&(a[l]=n[l]);n=a}for(var l in e.attrs)i.call(e.attrs,l)&&"className"!==l&&!i.call(n,l)&&(n[l]=e.attrs[l]);for(var l in(null!=o||null!=e.attrs.className)&&(n.className=null!=o?null!=e.attrs.className?String(e.attrs.className)+" "+String(o):o:null!=e.attrs.className?e.attrs.className:null),r&&(n.class=null),n)if(i.call(n,l)&&"key"!==l){t.attrs=n;break}return t}(l[e]||function(e){for(var t,n="div",r=[],o={};t=a.exec(e);){var i=t[1],s=t[2];if(""===i&&""!==s)n=s;else if("#"===i)o.id=s;else if("."===i)r.push(s);else if("["===t[3][0]){var c=t[6];c&&(c=c.replace(/\\(["'])/g,"$1").replace(/\\\\/g,"\\")),"class"===t[4]?r.push(c):o[t[4]]=""===c?c:c||!0}}return r.length>0&&(o.className=r.join(" ")),l[e]={tag:n,attrs:o}}(e),t):(t.tag=e,t)}}),o.register("2uPnQ",function(t,n){var r=o("k7iQv");"undefined"!=typeof window?(void 0===window.Promise?window.Promise=r:window.Promise.prototype.finally||(window.Promise.prototype.finally=r.prototype.finally),t.exports=window.Promise):void 0!==e?(void 0===e.Promise?e.Promise=r:e.Promise.prototype.finally||(e.Promise.prototype.finally=r.prototype.finally),t.exports=e.Promise):t.exports=r}),o.register("7lWrV",function(e,t){var n=o("gZZfO");// Returns `{path, params}` from `url`
e.exports=function(e){var t=e.indexOf("?"),r=e.indexOf("#"),o=r<0?e.length:r,i=t<0?o:t,a=e.slice(0,i).replace(/\/{2,}/g,"/");return a?("/"!==a[0]&&(a="/"+a),a.length>1&&"/"===a[a.length-1]&&(a=a.slice(0,-1))):a="/",{path:a,params:t<0?{}:n(e.slice(t+1,o))}}}),o.register("gZZfO",function(e,t){function n(e){try{return decodeURIComponent(e)}catch(t){return e}}e.exports=function(e){if(""===e||null==e)return{};"?"===e.charAt(0)&&(e=e.slice(1));for(var t=e.split("&"),r={},o={},i=0;i<t.length;i++){var a=t[i].split("="),l=n(a[0]),s=2===a.length?n(a[1]):"";"true"===s?s=!0:"false"===s&&(s=!1);var c=l.split(/\]\[?|\[/),u=o;l.indexOf("[")>-1&&c.pop();for(var f=0;f<c.length;f++){var d=c[f],p=c[f+1],m=""==p||!isNaN(parseInt(p,10));if(""===d){var l=c.slice(0,f).join();null==r[l]&&(r[l]=Array.isArray(u)?u.length:0),d=r[l]++}else if("__proto__"===d)break;if(f===c.length-1)u[d]=s;else{// Read own properties exclusively to disallow indirect
// prototype pollution
var h=Object.getOwnPropertyDescriptor(u,d);null!=h&&(h=h.value),null==h&&(u[d]=h=m?[]:{}),u=h}}}return o}}),o.register("8KlxE",function(e,t){var n=o("7lWrV");// Compiles a template into a function that takes a resolved path (without query
// strings) and returns an object containing the template parameters with their
// parsed values. This expects the input of the compiled template to be the
// output of `parsePathname`. Note that it does *not* remove query parameters
// specified in the template.
e.exports=function(e){var t=n(e),r=Object.keys(t.params),o=[],i=RegExp("^"+t.path.replace(// `:lang-:locale` in routes. This is all merged into one pass so I
// don't also accidentally escape `-` and make it harder to detect it to
// ban it from template parameters.
/:([^\/.-]+)(\.{3}|\.(?!\.)|-)?|[\\^$*+.()|\[\]{}]/g,function(e,t,n){return null==t?"\\"+e:(o.push({k:t,r:"..."===n}),"..."===n)?"(.*)":"."===n?"([^/]+)\\.":"([^/]+)"+(n||"")})+"$");return function(e){// First, check the params. Usually, there isn't any, and it's just
// checking a static set.
for(var n=0;n<r.length;n++)if(t.params[r[n]]!==e.params[r[n]])return!1;// If no interpolations exist, let's skip all the ceremony
if(!o.length)return i.test(e.path);var a=i.exec(e.path);if(null==a)return!1;for(var n=0;n<o.length;n++)e.params[o[n].k]=o[n].r?a[n+1]:decodeURIComponent(a[n+1]);return!0}}}),o.register("e9o88",function(e,t){var n=o("9eOch"),r=RegExp("^(?:key|oninit|oncreate|onbeforeupdate|onupdate|onbeforeremove|onremove)$");e.exports=function(e,t){var o={};if(null!=t)for(var i in e)n.call(e,i)&&!r.test(i)&&0>t.indexOf(i)&&(o[i]=e[i]);else for(var i in e)n.call(e,i)&&!r.test(i)&&(o[i]=e[i]);return o}});var i={},a={},l=o("iVcuU");l.trust=o("e2F9W"),l.fragment=o("7PZrX"),a=l;var s={},c=o("2uPnQ"),u=o("7EF0O");s=o("5y2KI")("undefined"!=typeof window?window:null,c,u.redraw);var u=o("7EF0O"),f=function(){return a.apply(this,arguments)};f.m=a,f.trust=a.trust,f.fragment=a.fragment,f.Fragment="[",f.mount=u.mount,f.route=o("4Ppi2"),f.render=o("j25vk"),f.redraw=u.redraw,f.request=s.request,f.jsonp=s.jsonp,f.parseQueryString=o("gZZfO"),f.buildQueryString=o("iRA82"),f.parsePathname=o("7lWrV"),f.buildPathname=o("cITMw"),f.vnode=o("dBs8J"),f.PromisePolyfill=o("k7iQv"),f.censor=o("e9o88");var d={},p=y(i=f),m={};function h(){}Object.defineProperty(m,"__esModule",{value:!0,configurable:!0}),Object.defineProperty(m,"default",{get:()=>v,set:void 0,enumerable:!0,configurable:!0});var v=function(e){function t(t){return new Proxy(h,{apply:(n,r,o)=>e(t,[],...o),get:(n,r)=>{let o=[r],i=new Proxy(h,{get:(e,t)=>(o.push(t),i),apply:(n,r,i)=>e(t,o,...i)});return i}})}return new Proxy(e=>t(e),{get:(e,n)=>t(e[n]||n)})},g=y(m);function y(e){return e&&e.__esModule?e:{default:e}}var w=function(e){return e.replace(/([A-Z])/g,function(e){return"-"+e[0].toLowerCase()})};d=function(){return(0,g.default)(function(e,t){for(var n=arguments.length,r=Array(n>2?n-2:0),o=2;o<n;o++)r[o-2]=arguments[o];var i=t.map(w).join("."),a=i.length?[e,i].join(".").replace(".$","#"):e;return p.default.apply(void 0,[a].concat(r))})};const{a:b}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{abbr:x}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{acronym:k}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{address:E}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{applet:O}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{area:j}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{article:S}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{aside:L}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{audio:N}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{b:P}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{base:A}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{basefont:T}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{bdi:C}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{bdo:R}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{big:z}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{blockquote:I}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{body:_}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{br:M}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{button:D}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{canvas:F}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{caption:$}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{center:U}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{cite:B}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{code:q}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{col:J}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{colgroup:Z}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{datalist:G}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{dd:W}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{del:H}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{details:K}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{dfn:X}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{dir:Q}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{div:V}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{dl:Y}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{dt:ee}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{em:et}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{embed:en}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{fieldset:er}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{figcaption:eo}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{figure:ei}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{font:ea}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{footer:el}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{form:es}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{frame:ec}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{frameset:eu}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{h1:ef}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{h2:ed}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{h3:ep}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{h4:em}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{h5:eh}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{h6:ev}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{head:eg}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{header:ey}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{hgroup:ew}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{hr:eb}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{html:ex}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{i:ek}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{iframe:eE}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{img:eO}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{input:ej}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{ins:eS}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{kbd:eL}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{keygen:eN}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{label:eP}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{legend:eA}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{li:eT}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{link:eC}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{map:eR}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mark:ez}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{menu:eI}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{meta:e_}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{meter:eM}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{nav:eD}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{noframes:eF}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{noscript:e$}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{object:eU}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{ol:eB}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{optgroup:eq}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{option:eJ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{output:eZ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{p:eG}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{param:eW}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{pre:eH}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{progress:eK}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{q:eX}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{rp:eQ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{rt:eV}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{ruby:eY}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{s:e0}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{samp:e1}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{script:e2}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{section:e9}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{select:e8}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{small:e3}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{source:e7}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{span:e5}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{strike:e6}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{strong:e4}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{style:te}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{sub:tt}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{summary:tn}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{sup:tr}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{table:to}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{tbody:ti}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{td:ta}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{textarea:tl}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{tfoot:ts}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{th:tc}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{thead:tu}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{time:tf}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{tr:td}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{track:tp}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{tt:tm}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{u:th}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{ul:tv}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{var_:tg}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{video:ty}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{wbr:tw}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{animate:tb}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{animateMotion:tx}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{animateTransform:tk}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{circle:tE}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{clipPath:tO}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{colorProfile:tj}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{defs:tS}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{desc:tL}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{discard:tN}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{ellipse:tP}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feBlend:tA}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feColorMatrix:tT}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feComponentTransfer:tC}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feComposite:tR}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feConvolveMatrix:tz}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feDiffuseLighting:tI}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feDisplacementMap:t_}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feDistantLight:tM}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feDropShadow:tD}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feFlood:tF}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feFuncA:t$}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feFuncB:tU}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feFuncG:tB}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feFuncR:tq}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feGaussianBlur:tJ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feImage:tZ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feMerge:tG}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feMergeNode:tW}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feMorphology:tH}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feOffset:tK}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{fePointLight:tX}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feSpecularLighting:tQ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feSpotLight:tV}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feTile:tY}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{feTurbulence:t0}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{filter:t1}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{foreignObject:t2}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{g:t9}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{hatch:t8}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{hatchpath:t3}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{image:t7}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{line:t5}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{linearGradient:t6}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{marker:t4}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mask:ne}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mesh:nt}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{meshgradient:nn}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{meshpatch:nr}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{meshrow:no}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{metadata:ni}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mpath:na}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{path:nl}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{pattern:ns}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{polygon:nc}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{polyline:nu}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{radialGradient:nf}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{rect:nd}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{set:np}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{solidcolor:nm}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{stop:nh}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{svg:nv}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{switch_:ng}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{symbol:ny}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{text:nw}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{textPath:nb}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{tspan:nx}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{unknown:nk}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{use:nE}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{view:nO}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{math:nj}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{maction:nS}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{maligngroup:nL}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{malignmark:nN}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{menclose:nP}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{merror:nA}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mfenced:nT}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mfrac:nC}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mglyph:nR}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mi:nz}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mlabeledtr:nI}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mlongdiv:n_}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mmultiscripts:nM}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mn:nD}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mo:nF}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mover:n$}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mpadded:nU}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mphantom:nB}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mroot:nq}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mrow:nJ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{ms:nZ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mscarries:nG}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mscarry:nW}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{msgroup:nH}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{msline:nK}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mspace:nX}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{msqrt:nQ}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{msrow:nV}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mstack:nY}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mstyle:n0}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{msub:n1}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{msup:n2}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{msubsup:n9}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mtable:n8}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mtd:n3}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mtext:n7}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{mtr:n5}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{munder:n6}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{munderover:n4}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{semantics:re}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{annotation:rt}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),{annotationXml:rn}=/*@__PURE__*/t(d)(/*@__PURE__*/t(i)),rr=Object.freeze({RED:"RED",YELLOW:"YELLOW",BLUE:"BLUE",GREEN:"GREEN"});rr.YELLOW,rr.YELLOW,rr.YELLOW,rr.YELLOW,rr.BLUE,rr.BLUE,rr.BLUE,rr.BLUE,rr.RED,rr.RED,rr.RED,rr.RED,rr.GREEN,rr.GREEN,rr.GREEN,rr.GREEN;const ro=[{id:"A19",1:{coords:["  ##","####","#   "],combi:[{dice:[1,2],pieces:[10,13,9]},{dice:[3,4],pieces:[5,16,9]}]},2:{coords:["####"," ## ","  # "],combi:[{dice:[5,6,7],pieces:[9,16,2]},{dice:[8,9,10],pieces:[13,10,9]}]}},{id:"B19",1:{coords:["## #"," ###","### "],combi:[{dice:[1],pieces:[9,14,3,10]},{dice:[2],pieces:[8,13,9,5]},{dice:[3],pieces:[1,9,14,8]},{dice:[4],pieces:[9,5,16,10]},{dice:[5],pieces:[10,6,9,12]}]},2:{coords:["### ","####","#  #"],combi:[{dice:[6],pieces:[16,5,13,15]},{dice:[7],pieces:[16,1,7,10]},{dice:[8],pieces:[7,14,10,3]},{dice:[9],pieces:[5,7,16,10]},{dice:[10],pieces:[5,9,14,8]}]}}],ri={card:ro[0]},ra=(e,t)=>t(e),rl=(e,t)=>ra(t.indexOf(e)-1,e=>e<0?t[t.length-1]:t[e]),rs=(e,t)=>ra(t.indexOf(e)+1,e=>e>=t.length?t[0]:t[e]);/*@__PURE__*/t(i).mount(document.getElementById("controls"),{view:e=>[ef("AB AN GA"),D({onclick:e=>ri.card=rl(ri.card,ro)},"<"),ro.indexOf(ri.card),D({onclick:e=>ri.card=rs(ri.card,ro)},">"),to()]});//# sourceMappingURL=index.a31cf184.js.map

//# sourceMappingURL=index.a31cf184.js.map
